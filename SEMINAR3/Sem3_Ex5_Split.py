n = input()
# Вводим в одной строке последовательность целых чисел

print(n)
# На экране - ровно такая же строка, как мы ввели

# Применим к этой строке оператор split()
n = n.split()

print(n)

# Он все непробельные подряд идущие символы преобразует в строки и 
# соберет в список

# Преобразуем теперь элементы массива n в целые числа: 

n = [int(i) for i in n]
print(n)

# Другой способ сформировать целочисленный массив из введенной строки чисел: 

n = map(int, input().split())
# Но здесь есть нюанс. 

# "1 2 3".split() => ['1', '2', '3']

# split преобразует строку в список слов
# По умолчанию разделителем является пробел
# Если мы хотим, чтобы split в качестве разделителя использовал другой символ, 
# его надо передать в качестве аргумента: 

# "1,2,3".split()       ==> ['1,2,3']
# "1,2,3".split(",")    ==> ['1', '2', '3']
# 
# split в процессе своей работы убирает: 
#   - пробелы
#   - конструкции \n, \t, \r
# 
# join - функция, обратная split'у: собираем отдельные слова в одну строку
# Как она применяется? 
# Сначала мы указываем символ (строку), который будет исполнять роль "соединителя"
# После него через точку и в круглых скобках (как аргумент) - список, к которому будет применяться данная функция
# Пример: 
# 
#   " ".(["Name", "Surname"] )
# Все значения в списке дложны быть строковыми
# 
# "7" + "7" = "77"
# "\n".join(["Name", "Surname"]) ==> "Name\nSurname"
# print осуществит переход на новую строку

# МЕТОДЫ title И capitalize
# title каждое слово в строке начинает с большой буквы, 
# capitalize - только первую букву строки делает большой. 

# МЕТОДЫ upper И lower - делают все буквы, соответственно, большими или маленькими

# count - подсчитывает число вхождений некоторого символа в строку. 

# replace - заменяет все вхождения одной подстроки в строке на другую
# Если в качестве второй подстроки использовать пустоту - "", то он уберет все соответствующие подстроки
# Все методы, работающие со строками, никоим образом не изменяют входную строку. 
# Результат - это всегда новый объект в новой области памяти, и если мы планируем с этим 
# результат работать дальше, его обязательно надо сохранить в некоторую переменную. 

# Методы можно "цеплять" друг к другу паровозиком. 

# метод index("<подстрока>") возвращает индекс первохо вхождения некоторой подстроки в исходную строку. 
# Но можно использовать второй параметр - начиная с какого индекса начинать просмотр!!! 
# index("<подстрока>", start_index)
# В случае отсутствия искомой подстроки метод ломается и порождает исключительную ситуацию

# Но есть метод find !!
# Он в случае неудачи вернет нам (-1)

# Метод strip() удалит лишние пробелы, \n, \t слева и справа
# Метод strip("!* ") уберет все символы, перечисленные в строке-параметре, если встретит их в начале 
# либо в конце исходной строки (не обязательно идущие подряд)
# rstrip уберет только справа, lstrip - только слева

# isdigit() - состоит ли наша строка только из цифр
# isalpha() - состоит ли наша строка только из букв

















