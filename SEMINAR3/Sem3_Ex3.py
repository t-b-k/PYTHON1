# Пусть у нас есть некоторый список: 
# n = [1, 4.4, "str", False, [1, 2]]
# n [-1] - доступ к последнему элементу
# n[-1][0] == 1
# len(n) - количество элемента в списке

# СПИСОК, С КОТОРЫМ БУДЕМ РАБОТАТЬ: 
# list_dict = [{"V": "S001"}, {"V": "S002"},
# 	         {"VI": "S001"}, {"VI": "S005"},
# 	         {"VII": " S005 "}, {"V": " S009 "},
# 	         {"VIII": " S007 "}]

# print(dir(list_dict[0]))

# for i in list_dict:
# 	    print(i.values())

# list(range(5)) => [0, 1, 2, 3, 4]

# ДОБАВЛЕНИЕ ЭЛЕМЕНТА В СПИСОК
# n.append(7) => [1, 4.4, "str", Flase, [1, 2], 7]
# n.append([7, 8]) => [1, 4.4, "str", False, [1, 2], 7, [7, 8]]

# ОПЕРАТОР EXTEND - расширение списка за счет элементов некоторого другого списка: 
# n.extend([7, 8]) => [1, 4.4, "str", False, [1, 2], 7, [7, 8], 7, 8] 

# ПОСЧИТАТЬ ЧИСЛО ВХОЖДЕНИЙ НЕКОТОРОГО ЭЛЕМЕНТА В СПИСОК: 
# n.count(8) == 1
# n.count(7) == 2

# ВСТАВКА ЭЛЕМЕНТА В ОПРЕДЕЛЕННОЕ МЕСТО СПИСКА
# n.insert(3, False) ==> [1, 4.4, "str", True, False, [1, 2], 7, [7, 8], 7, 8] 

# УДАЛЕНИЕ ЭЛЕМЕНТА ИЗ СПИСКА
# n.remove(7) ==> [1, 4.4, "str", True, False, [1, 2], [7, 8], 7, 8]  # Удалилась 1-я семерка
# n.pop() ==> Удаление только последнего элемента ==> [1, 4.4, "str", True, False, [1, 2], [7, 8], 7] 
# Метод pop() возвращает удаленное значение в качествте РЕЗУЛЬТАТА!!! 

# n.pop(0) ==> Удалит элемент с индексом 0 ==> [4.4, "str", True, False, [1, 2], [7, 8], 7] 

# dir(n) - покажет все методы, применимые к переменной n

n = [1, 4.4, "str", False, [1, 2]]
print(n)
print(dir(n))



# СОРТИРОВКА ПРИМЕНИМА ТОЛЬКО К ОДНОРООДНЫМ СПИСКАМ

# comprehension 
# List comprehension — это упрощенный подход к созданию списка, 
# который задействует цикл for, а также инструкции if-else для определения того, 
# что в итоге окажется в финальном списке.

# У list comprehension есть три основных преимущества.

# Простота. List comprehension позволяют избавиться от циклов for, 
# а также делают код более понятным. 
# В JavaScript, например, есть нечто похожее в виде map() и filter(), но новичками они воспринимаются сложнее.

# Скорость. List comprehension быстрее for-циклов, которые он и заменяет. 
# Это один из первых пунктов при рефакторинге Python-кода.

# Принципы функционального программирования. Это не так важно для начинающих, но функциональное программирование — 
# это подход, при котором изменяемые данные не меняются. Поскольку list comprehensions создают новый список, не 
# меняя существующий, их можно отнести к функциональному программированию.

# Comprehensions (представления) бывают 3-х типов: список, множество и словарь. 
# Если мы пишем кругрлые скобки, то это уже не comprehensions, а generator. 

# СПИСОК, С КОТОРЫМ БУДЕМ РАБОТАТЬ: 

list_dict = [{"V": "S001"}, {"V": "S002"},
	         {"VI": "S001"}, {"VI": "S005"},
	         {"VII": " S005 "}, {"V": " S009 "},
	         {"VIII": " S007 "}]

print(dir(list_dict[0]))

for i in list_dict:
	    print(list(i.values())[0].strip())
	    
# Запишем это короче: 

print(set([list(i.values())[0].strip() for i in list_dict]))
	    